#!/usr/bin/env python

# Requires Python 2.6+

DRYRUN = True

REMOTE_LOGIN            = 'osgsoftware'
REMOTE_HOST             = 'backup.grid.iu.edu'
REMOTE_BASE_PATH        = '/usr/local/backup/osgsoftware'
LOCAL_BACKUP_ROOT       = '/export/backup'
KOJIHOST                = 'koji-hub.batlab.org'
DBHOST                  = 'db-01.batlab.org'
RETRIES                 = 10
RETRY_WAIT              = 60
# TODO change this
NOTIFY_EMAILS           = ['matyas@cs.wisc.edu']
KEY                     = '/root/osg_backup_key'
BACKUP_TIME_OFFSET      = 86400     # 1 day
LAST_BACKUP_TIME_OFFSET = 86400 * 8 # 1 week + 1 day

DEDUPE_SCRIPT           = "%s/dedupe" % REMOTE_BASE_PATH
REMOTE_LOGIN_HOST       = "%s@%s" % (REMOTE_LOGIN, REMOTE_HOST)

MAIL_DELIVERY_METHOD    = 'sendmail'  # either 'sendmail' or 'smtp'

import glob
import re
import os
import shutil
from subprocess import Popen, PIPE, STDOUT
import sys
import tempfile
import time

import socket
from email.mime.text import MIMEText


class Error(Exception): pass
class CommandError(Error):
    def __init__(self, command, returncode, outerr):
        Error.__init__(self, "Command %r failed with returncode %d, output:\n%s" % (command, returncode, outerr))
        self.command = command
        self.returncode = returncode
        self.outerr = outerr


def compose_message(subject, text, recipients):
    if not isinstance(recipients, str):
        recipients = ', '.join(recipients)

    message = MIMEText(text)
    message['Subject'] = subject
    message['From'] = 'Offsite backup script <%s@%s>' % (os.getlogin(), socket.getfqdn())
    message['To'] = recipients

    return message


def send_message_smtp(message):
    import smtplib
    try:
        smtp = smtplib.SMTP('localhost')
        smtp.sendmail(message['From'], message['To'].split(', '), message.as_string())
        smtp.quit()
        return
    except smtplib.SMTPException, e:
        return str(e)


def send_message_sendmail(message):
    try:
        proc = Popen(['/usr/sbin/sendmail', '-oi', '-t'], stdin=PIPE, stdout=PIPE, stderr=STDOUT)
        outerr = proc.communicate(message.as_string())[0]
        ret = proc.returncode
        if ret != 0:
            return "exit %d from sendmail\noutput:\n%s" % (ret, outerr)
        return
    except OSError, e:
        return str(e)


def send_message(message):
    fail_reason = None
    if MAIL_DELIVERY_METHOD == 'smtp':
        fail_reason = send_message_smtp(message)
    elif MAIL_DELIVERY_METHOD == 'sendmail':
        fail_reason = send_message_sendmail(message)
    else:
        fail_reason = "Invalid MAIL_DELIVERY_METHOD %s" % MAIL_DELIVERY_METHOD

    if fail_reason is not None:
        print "Unable to send email message: %s" % fail_reason
        print "Message text:\n%s" % text


def notify_email(subject, text):
    send_message(compose_message(subject, text, NOTIFY_EMAILS))


def sbacktick(*args, **kwargs):
    # simplified version of utils.sbacktick from osgbuild
    sp_kwargs = kwargs.copy()
    sp_kwargs['stdout'] = PIPE
    sp_kwargs['stderr'] = STDOUT

    if DRYRUN:
        print str(args)
        return 0, ''

    proc = Popen(*args, **sp_kwargs)
    outerr = proc.communicate()[0]

    return proc.returncode, outerr


def csbacktick(*args, **kwargs):
    # checked version of sbacktick
    ret, outerr = sbacktick(*args, **kwargs)
    if ret != 0:
        raise CommandError(command=args[0], returncode=ret, outerr=outerr)
    return outerr


def remote_run_command(commandstr):
    return sbacktick(['ssh', '-i', KEY, REMOTE_LOGIN_HOST, commandstr])


def remote_run_script(script):
    if isinstance(script, list) or isinstance(script, tuple):
        script = "\n".join(script)

    if DRYRUN:
        print "---\n%s\n---" % script
        return 0, ''

    proc = Popen(['ssh', '-i', KEY, REMOTE_LOGIN_HOST, '/bin/bash -s'], stdin=PIPE, stdout=PIPE, stderr=STDOUT)
    outerr = proc.communicate(script)[0]

    return proc.returncode, outerr


def rsync_with_retry(src_path, remote_path, link=None):
    rsync_opts = ['--recursive', '--compress', '--quiet', '--rsh=ssh -i %(KEY)s' % globals()]

    if link:
        rsync_opts.append('--link-dest=%s' % os.path.relpath(link, remote_path))

    dest_path = "%s:%s" % (REMOTE_LOGIN_HOST, remote_path)
    count = 0
    while True:
        try:
            csbacktick(['rsync'] + rsync_opts + [src_path + '/', dest_path])
            return
        except CommandError, e:
            if count >= RETRIES:
                raise
            count += 1
            time.sleep(RETRY_WAIT)


def dedupe(pattern, substitution, from_dirs, logfile=None):
    if isinstance(from_dirs, str):
        from_dirs = [from_dirs]

    script = ['cd  %s' % REMOTE_BASE_PATH]
    for from_dir in from_dirs:
        line = "%s  %s  %s  %s" % (DEDUPE_SCRIPT, re.escape(pattern), re.escape(substitution), re.escape(from_dir))
        if logfile:
            line += "  >> %s  2>&1" % re.escape(logfile)
        script.append(line)

    return remote_run_script(script)


def backup_configs_roothome_and_database(workdir, remote_path):
    for tarball, directory in \
        [('etc.tar.gz'          , os.path.join(KOJIHOST , 'rootfs/etc')),
         ('roothome.tar.gz'     , os.path.join(KOJIHOST , 'rootfs/root')),
         ('pgsql.tar.gz'        , os.path.join(DBHOST   , 'rootfs/var/lib/pgsql')),
         ('pgsql-backup.tar.gz' , os.path.join(DBHOST   , 'rootfs/var/lib/pgsql-backup'))]:

        csbacktick(['tar', '-czpf', os.path.join(workdir, tarball), directory])
    rsync_with_retry(workdir, remote_path)


def backup_packages_with_dedupe(remote_path, remote_link_path, dedupe_pattern, dedupe_substitution, dedupe_logfile):
    packages_dir = os.path.join(KOJIHOST, 'kojifs/packages')
    if not os.path.isdir(packages_dir):
        raise Error(packages_dir + ' is not a directory')

    remote_run_command('mkdir -p  %s' % re.escape(os.path.join(remote_path, 'packages')))

    for package in os.listdir(packages_dir):
        package_dir = os.path.join(packages_dir, package)
        remote_package_dir = os.path.join(remote_path, 'packages', package)
        remote_link_dir = os.path.join(remote_link_path, 'packages', package)

        rsync_with_retry(package_dir, remote_package_dir, link=remote_link_dir)

        dedupe(pattern=dedupe_pattern, substitution=dedupe_substitution, from_dirs=[remote_package_dir], logfile=dedupe_logfile)


def main(argv):
    try:
        if remote_run_command('[[ -x %s ]]' % DEDUPE_SCRIPT)[0] != 0:
            raise Error('dedupe script missing from remote side')

        backup_date = time.strftime("%Y-%m-%d", time.localtime(time.time() - BACKUP_TIME_OFFSET))
        last_backup_date = time.strftime("%Y-%m-%d", time.localtime(time.time() - LAST_BACKUP_TIME_OFFSET))

        tempdir = tempfile.mkdtemp(prefix='osg-koji-backup')
        try:

            workdir = os.path.join(tempdir, backup_date)
            yesterdays_backups = os.path.join(LOCAL_BACKUP_ROOT, backup_date)
            remote_path = os.path.join(REMOTE_BASE_PATH, backup_date)
            remote_link_path = os.path.join(REMOTE_BASE_PATH, last_backup_date)

            os.makedirs(workdir)

            olddir = os.getcwd()
            os.chdir(yesterdays_backups)

            backup_configs_roothome_and_database(workdir, remote_path)

            logfile = os.path.join(REMOTE_BASE_PATH, 'dedupe-%s.log' % backup_date)
            remote_run_command('rm -f  %s' % re.escape(logfile))
            backup_packages_with_dedupe(remote_path, remote_link_path, backup_date, last_backup_date, logfile)

            os.chdir(olddir)

        finally:
            shutil.rmtree(tempdir)

    except Error, e:
        notify_email('OSG Koji offsite backups failed', str(e))
        return str(e)

    except Exception, e:
        notify_email('OSG Koji offsite backups died', str(e))
        raise

    notify_email('OSG Koji offsite backups succeeded (nt)', '')
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))

