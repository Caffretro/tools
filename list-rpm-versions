#!/usr/bin/python

"""
Usage:
  %(script)s [options] output-001 [packages...]
  %(script)s [options] --summarize [run-]20161220-1618 packages...

List version-release numbers for RPMs installed in an osg-test run output
directory, as found in output-NNN/output/osg-test-*.log

The output argument can also be a root.log from a koji/mock build,
or the raw output of an 'rpm -qa' command.

If any packages are specified, limit the results to just those packages.

If a run directory (or, just the timstamp string) is specified, summary
information will be printed for the listed packages across all output-NNN
subdirectories for that set of osg test runs.

Options:
  -A, --no-strip-arch  don't attempt to strip .arch from package names
  -D, --no-strip-dist  don't attempt to strip .dist tag from package releases

  -s, --summarize      summarize results for all output subdirs
  -l, --list-outputs   list output numbers (summarize mode only)
  -L, --max-outputs N  list at most N output numbers per NVR (-1 for unlimited)
"""

import collections
import getopt
import glob
import stat
import sys
import os
import re


GLOBAL_RUNS_DIR = "/osgtest/runs"

outdir     = None
pkgs       = []
strip_arch = True
strip_dist = True
summarize  = False
list_nums  = False
max_nums   = 7

arch_pat = r'\.(x86_64|i[3-6]86|noarch|src)$'
dist_pat = r'((\.osg(\d+)?)?\.[es]l[5-9](_[\d.]+)?(\.centos)?|\.osg|\.fc\d+)$'

def usage(msg=None):
    if msg:
        print msg
        print
    print __doc__ % {"script": os.path.basename(__file__)}
    sys.exit()

def parseargs():
    global outdir, pkgs, strip_arch, strip_dist, summarize, list_nums, max_nums
    longopts = ['no-strip-arch', 'no-strip-dist', 'summarize',
                'list-outputs', 'max-outputs=', 'help']
    ops,args = getopt.getopt(sys.argv[1:], 'ADslL:', longopts)
    for op,val in ops:
        if   op in ('-A', '--no-strip-arch') : strip_arch = False
        elif op in ('-D', '--no-strip-dist') : strip_dist = False
        elif op in ('-s', '--summarize')     : summarize  = True
        elif op in ('-l', '--list-outputs')  : list_nums  = True
        elif op in ('-L', '--max-outputs')   : list_nums  = True; \
                                               max_nums   = int(val)
        elif op == '--help'                  : usage()

    if not args:
        usage("Must provide a test run output location")

    outdir = args[0]
    pkgs   = args[1:]

    if max_nums < 0:
        max_nums = 99999

    if summarize and not pkgs:
        usage("Must specify package list for --summarize")

def arch_strip(na):
    return re.sub(arch_pat, '', na)

def dist_strip(evr):
    ev,r = evr.split('-')
    r = re.sub(dist_pat, '', r)
    return '-'.join([ev,r])

def nvrgen(items):
    # generate sequence of ["name.arch", "epoch:version-release"] pairs
    while items:
        na, evr = items[:2]
        if strip_arch:
            na = arch_strip(na)
        if strip_dist:
            evr = dist_strip(evr)
        if evr.startswith("0:"):
            evr = evr[2:]
        yield [na,evr]
        items[:2] = []

def isdir(fn):
    try:
        return stat.S_ISDIR(os.stat(fn).st_mode)
    except OSError:
        return False

def rpm_qa2na_vr(line):
    line = re.sub(r'(\.rpm)?\r?\n?$', '', line)
    if re.search(arch_pat, line):
        nvr,a = line.rsplit('.', 1)
    else:
        nvr,a = line, None
    n,v,r = nvr.rsplit('-',2)
    if a and not strip_arch:
        na = '.'.join((n,a))
    else:
        na = n
    if strip_dist:
        r = re.sub(dist_pat, '', r)
    vr = '-'.join((v,r))
    return [na,vr]

def nvrmap(output):
    if not isdir(output):
        log = output
    else:
        globpat = "%s/output/osg-test-*.log" % output
        log = glob.glob(globpat)
        if len(log) != 1:
            raise RuntimeError("could not find '%s'" % globpat)
        log = log[0]

    # split this way since there can be more than one item per line
    txt = open(log).read()
    if ' ' in txt:
        # strip "DEBUG util.py:388:  " in case this is coming from a root.log
        txt = re.sub(r'\n[A-Z]+ .*?:\d+:  ', r'\n', txt)
        # don't include Install list from cleanup/downgrade
        txt = re.sub(r'\nosgtest: .* special_cleanup[\d\D]*', r'\n', txt)
        items_pat = (r'^(?:Dependency )?(?:Installed|Updated|Replaced):\n'
                     r'(.*?)\n(?:\n|(?=[^ ]))')
        items = ' '.join(re.findall(items_pat, txt, re.S | re.M)).split()
        return dict(nvrgen(items))
    else:
        # at most 1-word per line; assume this is 'rpm -qa' output
        return dict(map(rpm_qa2na_vr, txt.split()))

def print_table(header, table):
    table = [header] + table
    widths = [ max(map(len,col)) for col in zip(*table) ]
    table[1:1] = [[ '-' * n for n in map(len,header) ]]
    for i,row in enumerate(table):
        spacing = [ w-len(x) for x,w in zip(row,widths) ]
        print '  '.join( r + ' ' * s for r,s in zip(row,spacing) ).rstrip()

def single_output_pkg_vrs(output, pkgs):
    rpms = nvrmap(output)

    # arch-stripped rpm names
    if strip_arch:
        bare_rpms = set(rpms)
    else:
        bare_rpms = set(map(arch_strip, rpms))

    match_rpms = set(pkgs)
    missing_rpms = match_rpms - bare_rpms

    if strip_arch:
        all_match_rpms = match_rpms
    else:
        all_match_rpms = ( set(x for x in rpms if arch_strip(x) in match_rpms)
                         | missing_rpms )

    display_pkgs = sorted(all_match_rpms if pkgs else rpms)

    return [ [pkg, rpms.get(pkg, '-')] for pkg in display_pkgs ]

def display_single_output(output, pkgs):
    pkg_vrs = single_output_pkg_vrs(output, pkgs)
    name_field = "Package" if strip_arch else "Package.Arch"
    print_table([name_field, output], pkg_vrs)

class autodict(collections.defaultdict):
    def __init__(self,*other):
        collections.defaultdict.__init__(self, self.__class__, *other)
    def __add__ (self, other):
        return other
    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, dict.__repr__(self))

try:
    import rpm
    from rpmUtils.miscutils import stringToVersion
    def rpmvercmp(a,b):
        return rpm.labelCompare(*[stringToVersion(x) for x in (a,b)])
except ImportError:
    rpmvercmp = None

def outputnum(output):
    m = re.search(r'(?:/|^)output-(\d+)/?', output)
    return m.group(1) if m else output

def get_summary_header():
    name_field = "Package" if strip_arch else "Package.Arch"
    header = [name_field, "Version-Release", "Count"]
    if list_nums:
        header.append("Output-Nums")
    return header

def get_run_output_dirs(rundir):
    if isdir(rundir):
        pass  # OK, specified path exists
    elif re.match(r'run-20[0-9]{6}-[0-9]{4}$', rundir):
        rundir = "%s/%s" % (GLOBAL_RUNS_DIR, rundir)
    elif re.match(r'20[0-9]{6}-[0-9]{4}$', rundir):
        rundir = "%s/run-%s" % (GLOBAL_RUNS_DIR, rundir)

    globpat = "%s/output-[0-9][0-9][0-9]*/" % rundir
    outputs = sorted(glob.glob(globpat))

    if not outputs:
        raise RuntimeError("no output dirs found under '%s'" % rundir)

    return outputs


def summarize_outputs(rundir, pkgs):
    outputs = get_run_output_dirs(rundir)

    pkgstats = autodict()
    for output in outputs:
        pkg_vrs = single_output_pkg_vrs(output, pkgs)
        for pkg,vr in pkg_vrs:
            pkgstats[pkg][vr] += [outputnum(output)]

    header = get_summary_header()
    pkgstatslist = []
    for pkg in sorted(pkgstats):
        for vr in sorted(pkgstats[pkg], cmp=rpmvercmp):
            row = [pkg, vr, str(len(pkgstats[pkg][vr]))]
            if list_nums:
                nums_str =','.join(pkgstats[pkg][vr][:max_nums])
                if len(pkgstats[pkg][vr]) > max_nums:
                    nums_str += ",..."
                row.append(nums_str)
            pkgstatslist.append(row)
        pkgstatslist.append([''] * len(header))

    print_table(header, pkgstatslist)

def main():
    parseargs()
    if summarize:
        summarize_outputs(outdir, pkgs)
    else:
        display_single_output(outdir, pkgs)

if __name__ == '__main__':
    try:
        main()
    except RuntimeError as e:
        print >>sys.stderr, "Error: %s" % e.message
        sys.exit(1)
    except getopt.GetoptError as e:
        usage(e.msg)

