#!/usr/bin/env python
DRYRUN = True

REMOTE_LOGIN            = 'osgsoftware'
REMOTE_HOST             = 'backup.grid.iu.edu'
REMOTE_BASE_PATH        = '/usr/local/backup/osgsoftware'
LOCAL_BACKUP_ROOT       = '/export/backup'
KOJIHOST                = 'koji-hub.batlab.org'
DBHOST                  = 'db-01.batlab.org'
RETRIES                 = 10
RETRY_WAIT              = 60
# TODO change this
NOTIFY_EMAILS           = ['matyas@cs.wisc.edu']
KEY                     = '/root/osg_backup_key'
BACKUP_TIME_OFFSET      = 86400     # 1 day
LAST_BACKUP_TIME_OFFSET = 86400 * 8 # 1 week + 1 day

DEDUPE_SCRIPT           = "%s/dedupe" % REMOTE_BASE_PATH
REMOTE_LOGIN_HOST       = "%s@%s" % (REMOTE_LOGIN, REMOTE_HOST)



import glob
import re
import os
import shutil
import subprocess
import sys
import tempfile
import time

import smtplib
import socket
try:
    from email.mime.text import MIMEText
except ImportError:
    from email.MIMEText import MIMEText


class Error(Exception): pass
class CompressError(Error): pass
class RsyncError(Error):
    def __init__(self, msg, returncode=None, outerr=None):
        Exception.__init__(self, msg)
        self.returncode = returncode
        self.outerr = outerr

    def str(self):
        return "RsyncError(%r)\nreturncode: %s\nouterr: %s" % (msg, returncode, outerr)



def send_message(subject, text, recipients):
    if isinstance(recipients, str):
        recipients = [recipients]
    message = MIMEText(text)
    from_addr = 'Offsite backup script <%s@%s>' % (os.getlogin(), socket.getfqdn())
    message['Subject'] = subject
    message['From'] = from_addr
    message['To'] = ', '.join(recipients)
    smtp = smtplib.SMTP('localhost')
    smtp.sendmail(from_addr, recipients, message.as_string())
    smtp.quit()


def sbacktick(*args, **kwargs):
    # simplified version of utils.sbacktick from osgbuild
    sp_kwargs = kwargs.copy()
    sp_kwargs['stdout'] = subprocess.PIPE
    sp_kwargs['stderr'] = subprocess.STDOUT

    if DRYRUN:
        print str(args)
        return 0, ''

    proc = subprocess.Popen(*args, **sp_kwargs)
    outerr = proc.communicate()[0]

    return proc.returncode, outerr


def remote_run_command(commandstr):
    return sbacktick(['ssh', '-i', KEY, REMOTE_LOGIN_HOST, commandstr])


def remote_run_script(script):
    if isinstance(script, list) or isinstance(script, tuple):
        script = "\n".join(script)

    if DRYRUN:
        print "---\n%s\n---" % script
        return 0, ''

    proc = subprocess.Popen(['ssh', '-i', KEY, REMOTE_LOGIN_HOST, '/bin/bash -s'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    outerr = proc.communicate(script)[0]

    return proc.returncode, outerr


def rsync(src_path, dest_path, rsync_opts=None):
    rsync_command = ['rsync']
    if rsync_opts:
        rsync_command += rsync_opts
    rsync_command += [src_path, dest_path]
    return sbacktick(rsync_command)


def checked_rsync_with_retry(src_path, remote_path, link=None):
    rsync_opts = ['--recursive', '--compress', '--quiet', '--rsh=ssh -i %(KEY)s' % globals()]

    if link:
        rsync_opts.append('--link-dest=%s' % os.path.relpath(link, remote_path))

    dest_path = "%s:%s" % (REMOTE_LOGIN_HOST, remote_path)
    count = 0
    while True:
        ret, outerr = rsync(src_path + '/', dest_path, rsync_opts)
        if ret == 0:
            return
        if count >= RETRIES:
            raise RsyncError("Hit max retries while rsyncing %(src_path)s to %(dest_path)s; giving up" % locals(), ret, outerr)
        else:
            count += 1
            time.sleep(RETRY_WAIT)


def checked_compress(tarball, directory):
    ret, outerr = sbacktick(['tar', '-czpf', tarball, directory])

    if ret != 0:
        raise CompressError("Error compressing %(directory)s to %(tarball)s:\n%(outerr)s" % locals())


def dedupe_is_present():
    return remote_run_command('[[ -x %s ]]' % DEDUPE_SCRIPT)[0] == 0


def dedupe(pattern, substitution, from_dirs, logfile=None):
    if isinstance(from_dirs, str):
        from_dirs = [from_dirs]

    script = ['cd  %s' % REMOTE_BASE_PATH]
    for from_dir in from_dirs:
        line = "%s  %s  %s  %s" % (DEDUPE_SCRIPT, re.escape(pattern), re.escape(substitution), re.escape(from_dir))
        if logfile:
            line += "  >> %s  2>&1" % re.escape(logfile)
        script.append(line)

    return remote_run_script(script)


def backup_configs_roothome_and_database(workdir, remote_path):
    for tarball, directory in \
        [('etc.tar.gz'          , os.path.join(KOJIHOST , 'rootfs/etc')),
         ('roothome.tar.gz'     , os.path.join(KOJIHOST , 'rootfs/root')),
         ('pgsql.tar.gz'        , os.path.join(DBHOST   , 'rootfs/var/lib/pgsql')),
         ('pgsql-backup.tar.gz' , os.path.join(DBHOST   , 'rootfs/var/lib/pgsql-backup'))]:

        checked_compress(os.path.join(workdir, tarball), directory)
    checked_rsync_with_retry(workdir, remote_path)


def backup_packages_with_dedupe(remote_path, remote_link_path, dedupe_pattern, dedupe_substitution, dedupe_logfile):
    packages_dir = os.path.join(KOJIHOST, 'kojifs/packages')
    if not os.path.isdir(packages_dir):
        raise Error(packages_dir + ' is not a directory')

    remote_run_command('mkdir -p  %s' % re.escape(os.path.join(remote_path, 'packages')))

    for package in os.listdir(packages_dir):
        package_dir = os.path.join(packages_dir, package)
        remote_package_dir = os.path.join(remote_path, 'packages', package)
        remote_link_dir = os.path.join(remote_link_path, 'packages', package)

        checked_rsync_with_retry(package_dir, remote_package_dir, link=remote_link_dir)

        dedupe(pattern=dedupe_pattern, substitution=dedupe_substitution, from_dirs=[remote_package_dir], logfile=dedupe_logfile)


def main(argv):
    if not dedupe_is_present():
        print 'dedupe script missing from remote side'
        return 3

    backup_date = time.strftime("%Y-%m-%d", time.localtime(time.time() - BACKUP_TIME_OFFSET))
    last_backup_date = time.strftime("%Y-%m-%d", time.localtime(time.time() - LAST_BACKUP_TIME_OFFSET))

    tempdir = tempfile.mkdtemp(prefix='osg-koji-backup')
    try:

        workdir = os.path.join(tempdir, backup_date)
        yesterdays_backups = os.path.join(LOCAL_BACKUP_ROOT, backup_date)
        remote_path = os.path.join(REMOTE_BASE_PATH, backup_date)
        remote_link_path = os.path.join(REMOTE_BASE_PATH, last_backup_date)

        os.makedirs(workdir)

        olddir = os.getcwd()
        try:

            os.chdir(yesterdays_backups)

            try:
                backup_configs_roothome_and_database(workdir, remote_path)

                logfile = os.path.join(REMOTE_BASE_PATH, 'dedupe-%s.log' % backup_date)
                remote_run_command('rm -f  %s' % re.escape(logfile))
                backup_packages_with_dedupe(remote_path, remote_link_path, backup_date, last_backup_date, logfile)
            except Error, e:
                print str(e)
                #send_message('Offsite backups failed', str(e), NOTIFY_EMAILS)
                return 1

        finally:
            os.chdir(olddir)

    finally:
        shutil.rmtree(tempdir)

    #send_message('Offsite backups succeeded', 'Offsite backups succeeded', NOTIFY_EMAILS)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))

